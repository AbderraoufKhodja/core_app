import 'dart:async';
import 'dart:typed_data';

import 'package:bloc/bloc.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:fibali/fibali_core/models/order_event.dart';
import 'package:firebase_storage/firebase_storage.dart';

import './bloc.dart';

class SellerOrderEventsBloc extends Bloc<SellerOrderEventsEvent, OrderEventsState> {
  final _db = FirebaseFirestore.instance;
  final _dbs = FirebaseStorage.instance;

  SellerOrderEventsBloc() : super(SellerOrderEventsInitial()) {
    on<LoadSellerOrderEvents>((event, emit) {
      emit(SellerOrderEventsLoading());
      final orderEvents = getOrderEvents(orderID: event.orderID);
      emit(SellerOrderEventsLoaded(orderEvents: orderEvents));
    });
  }

  Future<DocumentSnapshot<Map<String, dynamic>>> getStore({required String storeID}) {
    return _db.collection('stores').doc(storeID).get();
  }

  Future<void> markAsSeen({
    required String currentUserID,
    required String orderID,
  }) {
    return _db.collection('orders').doc(orderID).update({
      'isSeen.' + currentUserID: true,
    });
  }

  Future<void> addOrderEvent({
    required OrderEvent orderEvent,
    required List<Uint8List>? photos,
  }) async {
    final _orderRef = OrderEvent.ref(orderID: orderEvent.orderID!).doc();

    if (photos != null) {
      // TODO check if i need to add a name to image to uploaded images to firebase is it generated by firebase
      photos.forEach((photo) async {
        final _photoRef = _dbs.ref().child('orders').child(_orderRef.id);
        final metadata = SettableMetadata(contentType: 'image/jpeg');
        await _photoRef.putData(photo, metadata).whenComplete(
          () async {
            final photoUrl = await _photoRef.getDownloadURL();
            if (orderEvent.photoUrls == null) {
              orderEvent.photoUrls = [];
              orderEvent.photoUrls?.add(photoUrl);
            } else
              orderEvent.photoUrls?.add(photoUrl);
          },
        );
      });
    }

    _orderRef.set(orderEvent);
  }

  Stream<QuerySnapshot<OrderEvent>> getOrderEvents({
    required String orderID,
  }) {
    return OrderEvent.ref(orderID: orderID)
        .orderBy('timestamp', descending: false)
        .snapshots(includeMetadataChanges: true);
  }
}
